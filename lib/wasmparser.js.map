{"version":3,"file":"wasmparser.js","mappings":"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","sources":["webpack://sorobanwasmparser/webpack/universalModuleDefinition","webpack://sorobanwasmparser/external umd \"@stellar/stellar-base\"","webpack://sorobanwasmparser/webpack/bootstrap","webpack://sorobanwasmparser/webpack/runtime/define property getters","webpack://sorobanwasmparser/webpack/runtime/hasOwnProperty shorthand","webpack://sorobanwasmparser/./src/xdr-reader.js","webpack://sorobanwasmparser/./src/wasm-section-reader.js","webpack://sorobanwasmparser/./src/xdr-spec-parser.js","webpack://sorobanwasmparser/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@stellar/stellar-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@stellar/stellar-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sorobanwasmparser\"] = factory(require(\"@stellar/stellar-base\"));\n\telse\n\t\troot[\"sorobanwasmparser\"] = factory(root[\"@stellar/stellar-base\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__755__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__755__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n *\r\n * @param {Buffer} buffer\r\n * @param {{read: function}} xdrContract\r\n * @return {{}[]}\r\n */\r\nexport function parseSectionEntriesXdr(buffer, xdrContract) {\r\n    const reader = new XdrReader(buffer)\r\n    const entries = []\r\n    while (!reader.eof) {\r\n        entries.push(xdrContract.read(reader))\r\n    }\r\n    return entries\r\n}\r\n\r\nclass XdrReader {\r\n    /**\r\n     * @constructor\r\n     * @param {Buffer} source - Buffer containing serialized data\r\n     */\r\n    constructor(source) {\r\n        if (!Buffer.isBuffer(source)) {\r\n            if (source instanceof Array) {\r\n                source = Buffer.from(source)\r\n            } else\r\n                throw new Error('Source not specified')\r\n        }\r\n\r\n        this._buffer = source\r\n        this._length = source.length\r\n        this._index = 0\r\n    }\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _buffer\r\n    /**\r\n     * @type {Number}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _length\r\n    /**\r\n     * @type {Number}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _index\r\n\r\n    /**\r\n     * Check if the reader reached the end of the input buffer\r\n     * @return {Boolean}\r\n     */\r\n    get eof() {\r\n        return this._index === this._length\r\n    }\r\n\r\n    /**\r\n     * Advance reader position, check padding and overflow\r\n     * @param {Number} size - Bytes to read\r\n     * @return {Number} Position to read from\r\n     * @private\r\n     */\r\n    advance(size) {\r\n        const from = this._index\r\n        // advance cursor position\r\n        this._index += size\r\n        // check buffer boundaries\r\n        if (this._length < this._index)\r\n            throw new Error(\r\n                'attempt to read outside the boundary of the buffer'\r\n            )\r\n        // check that padding is correct for Opaque and String\r\n        const padding = 4 - (size % 4 || 4)\r\n        if (padding > 0) {\r\n            for (let i = 0; i < padding; i++)\r\n                if (this._buffer[this._index + i] !== 0)\r\n                    // all bytes in the padding should be zeros\r\n                    throw new Error('Invalid padding')\r\n            this._index += padding\r\n        }\r\n        return from\r\n    }\r\n\r\n    /**\r\n     * Reset reader position\r\n     */\r\n    rewind() {\r\n        this._index = 0\r\n    }\r\n\r\n    /**\r\n     * Read byte array from the buffer\r\n     * @param {Number} size - Bytes to read\r\n     * @return {Buffer} - Sliced portion of the underlying buffer\r\n     */\r\n    read(size) {\r\n        const from = this.advance(size)\r\n        return this._buffer.subarray(from, from + size)\r\n    }\r\n\r\n    /**\r\n     * Read i32 from buffer\r\n     * @return {Number}\r\n     */\r\n    readInt32BE() {\r\n        return this._buffer.readInt32BE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read u32 from buffer\r\n     * @return {Number}\r\n     */\r\n    readUInt32BE() {\r\n        return this._buffer.readUInt32BE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read i64 from buffer\r\n     * @return {BigInt}\r\n     */\r\n    readBigInt64BE() {\r\n        return this._buffer.readBigInt64BE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Read u64 from buffer\r\n     * @return {BigInt}\r\n     */\r\n    readBigUInt64BE() {\r\n        return this._buffer.readBigUInt64BE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Read float from buffer\r\n     * @return {Number}\r\n     */\r\n    readFloatBE() {\r\n        return this._buffer.readFloatBE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read double from buffer\r\n     * @return {Number}\r\n     */\r\n    readDoubleBE() {\r\n        return this._buffer.readDoubleBE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Ensure that input buffer has been consumed in full, otherwise it's a type mismatch\r\n     */\r\n    ensureInputConsumed() {\r\n        if (this._index !== this._length)\r\n            throw new Error(`Invalid XDR contract typecast - source buffer not entirely consumed`)\r\n    }\r\n}","/**\r\n * Minimalistic WASM metadata reader\r\n */\r\nexport class WasmSectionReader {\r\n    constructor(data) {\r\n        this.data = data\r\n    }\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     * @private\r\n     */\r\n    data\r\n    /**\r\n     * Current reader position\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    pointer = 8\r\n\r\n    /**\r\n     * Read custom metadata sections from raw WASM\r\n     * @return {{name: string, contents: Buffer}[]}\r\n     */\r\n    readCustomSections() {\r\n        const sections = []\r\n        while (this.pointer < this.data.length) {\r\n            const sectionType = this.readUint8()\r\n            let length = this.readVarUint32()\r\n            if (sectionType === 0) { //accumulate only custom sections\r\n                const sectionStart = this.pointer\r\n                const name = this.readString()\r\n                length -= this.pointer - sectionStart\r\n                sections.push({\r\n                    name,\r\n                    contents: this.data.subarray(this.pointer, this.pointer + length)\r\n                })\r\n            }\r\n            this.pointer += length\r\n        }\r\n        return sections\r\n    }\r\n\r\n    /**\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    readUint8() {\r\n        return this.data.readUint8(this.pointer++)\r\n    }\r\n\r\n    /**\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    readVarUint32() {\r\n        let result = 0\r\n        let shift = 0\r\n        while (true) {\r\n            let byte = this.readUint8()\r\n            result |= (byte & 0x7f) << shift\r\n            shift += 7\r\n            if ((byte & 0x80) === 0)\r\n                break\r\n        }\r\n        return result >>> 0\r\n    }\r\n\r\n    /**\r\n     * @return {string}\r\n     * @private\r\n     */\r\n    readString() {\r\n        const length = this.readVarUint32()\r\n        const contents = this.data.subarray(this.pointer, this.pointer + length)\r\n        this.pointer += length\r\n        return contents.toString('utf-8')\r\n    }\r\n}","export function parseContractMeta(meta) {\r\n    const res = {}\r\n    for (const {_value} of meta) {\r\n        const key = _value.key().toString()\r\n        const val = _value.val().toString()\r\n        switch (key) {\r\n            case 'rsver':\r\n                res.rustVersion = val\r\n                break\r\n            case 'rssdkver':\r\n                res.sdkVersion = val\r\n                break\r\n            default:\r\n                res[key] = val\r\n                break\r\n        }\r\n    }\r\n    return res\r\n}\r\n\r\nexport function parseSpec(entries) {\r\n    return new SpecParser().parse(entries)\r\n}\r\n\r\n\r\nclass SpecParser {\r\n    constructor() {\r\n        this.res = {}\r\n    }\r\n\r\n    /**\r\n     * @type {{}}\r\n     */\r\n    res\r\n\r\n    addSpec(key, attr, parser) {\r\n        //this.parseFunction(attr), attr.doc\r\n        let spec = this.res[key]\r\n        if (spec === undefined) {\r\n            spec = this.res[key] = {}\r\n        }\r\n        parser.call(this, attr, spec)\r\n    }\r\n\r\n    parse(entries) {\r\n        for (const spec of entries) {\r\n            const value = spec.value()\r\n            const {_attributes: attr} = value\r\n            switch (spec._arm) {\r\n                case 'functionV0':\r\n                    this.addSpec('functions', attr, this.parseFunction)\r\n                    break\r\n                case 'udtStructV0':\r\n                    this.addSpec('structs', attr, this.parseStruct)\r\n                    break\r\n                case 'udtUnionV0':\r\n                    this.addSpec('unions', attr, this.parseUnion)\r\n                    break\r\n                case 'udtEnumV0':\r\n                    this.addSpec('enums', attr, this.parseEnum)\r\n                    break\r\n                case 'udtErrorEnumV0':\r\n                    this.addSpec('errors', attr, this.parseError)\r\n                    break\r\n                case 'eventV0':\r\n                    this.addSpec('events', attr, this.parseEvent)\r\n                    break\r\n                default:\r\n                    console.log('Unknown spec type: ' + spec._arm)\r\n                    break\r\n            }\r\n        }\r\n        return this.res\r\n    }\r\n\r\n    parseFunction(attr, into) {\r\n        into[attr.name.toString()] = this.withDocs({\r\n            inputs: attr.inputs.map(a => this.parseFuncArgument(a)),\r\n            outputs: attr.outputs.map(o => this.parseParameterType(o))\r\n        }, attr)\r\n    }\r\n\r\n    parseStruct(attr, into) {\r\n        const fields = {}\r\n        for (const f of attr.fields) {\r\n            this.parseParameter(f, fields)\r\n        }\r\n        into[this.parseStructName(attr)] = this.withDocs({fields}, attr)\r\n    }\r\n\r\n    parseUnion(attr, into) {\r\n        const cases = {}\r\n        for (const c of attr.cases) {\r\n            const value = c.value()\r\n            cases[value.name().toString()] = value.type ?\r\n                value.type().map(t => this.parseParameterType(t)) :\r\n                []\r\n        }\r\n        into[this.parseStructName(attr)] = this.withDocs({cases}, attr)\r\n    }\r\n\r\n    parseEnum(attr, into) {\r\n        const cases = {}\r\n        for (const c of attr.cases) {\r\n            const value = c.value()\r\n            if (value.name) {\r\n                cases[value.name().toString()] = value.value()\r\n            } else {\r\n                const attr = c._attributes\r\n                cases[attr.name.toString()] = this.withDocs({value}, attr)\r\n            }\r\n        }\r\n        into[this.parseStructName(attr)] = this.withDocs({cases}, attr)\r\n    }\r\n\r\n    parseError(attr, into) {\r\n        for (const c of attr.cases) {\r\n            const attr = c._attributes\r\n            into[attr.name.toString()] = this.withDocs({value: attr.value}, attr)\r\n        }\r\n    }\r\n\r\n    parseEvent(attr, into) {\r\n        let dataFormat\r\n        switch (attr.dataFormat.value) {\r\n            case 1:\r\n                dataFormat = 'Vec'\r\n                break\r\n            case 2:\r\n                dataFormat = 'Map'\r\n                break\r\n            default:\r\n                dataFormat = attr.dataFormat.name\r\n                break\r\n        }\r\n        const evt = {\r\n            prefixTopics: attr.prefixTopics.map(t => t.toString()),\r\n            params: attr.params.map(p => {\r\n                const pa = p._attributes\r\n                const param = {\r\n                    name: pa.name.toString(),\r\n                    type: this.parseParameterType(pa.type),\r\n                    location: pa.location.value === 0 ? 'data' : 'topics'\r\n                }\r\n                return this.withDocs(param, pa)\r\n            }),\r\n            dataFormat\r\n        }\r\n        into[this.parseStructName(attr)] = this.withDocs(evt, attr)\r\n    }\r\n\r\n    parseParameterType(type) {\r\n        const typeName = type.switch().name\r\n        switch (typeName) {\r\n            case 'scSpecTypeOption':\r\n                return `Option<${this.parseParameterType(type.value().valueType())}>`\r\n            case 'scSpecTypeBytesN':\r\n                return `BytesN<${type.value().n()}>`\r\n            case 'scSpecTypeVec':\r\n                return `Vec<${this.parseParameterType(type.value().elementType())}>`\r\n            case 'scSpecTypeMap':\r\n                return `Map<${this.parseParameterType(type.value().keyType())}, ${this.parseParameterType(type.value().valueType())}>`\r\n            case 'scSpecTypeResult':\r\n                return `Result<${this.parseParameterType(type.value().okType())}, ${this.parseParameterType(type.value().errorType())}>`\r\n            case 'scSpecTypeTuple':\r\n                return `(${type.value().valueTypes().map(v => this.parseParameterType(v)).join(', ')})`\r\n            case 'scSpecTypeUdt':\r\n                return type.value().name().toString()\r\n            default:\r\n                let res = typeName.replace('scSpecType', '')\r\n                if (/^[IU](8|16|32|64|128)$/.test(res) || res === 'Bool') { //remap standard int types\r\n                    res = res.toLowerCase()\r\n                }\r\n                return res\r\n        }\r\n    }\r\n\r\n    parseStructName(value) {\r\n        let structName = value.name.toString()\r\n        if (value.lib.length) {\r\n            structName += ':' + value.lib.toString()\r\n        }\r\n        return structName\r\n    }\r\n\r\n    parseParameter(param, into) {\r\n        const attr = param._attributes\r\n        into[attr.name.toString()] = this.withDocs({type: this.parseParameterType(attr.type)}, attr)\r\n    }\r\n\r\n    parseFuncArgument(arg) {\r\n        const attr = arg._attributes\r\n        return this.withDocs({\r\n            name: attr.name.toString(),\r\n            type: this.parseParameterType(attr.type)\r\n        }, attr)\r\n    }\r\n\r\n    withDocs(descriptor, attr) {\r\n        if (attr.doc?.length) {\r\n            descriptor.doc = attr.doc.toString()\r\n        }\r\n        return descriptor\r\n    }\r\n}\r\n\r\n","import {xdr} from '@stellar/stellar-base'\r\nimport {parseSectionEntriesXdr} from './xdr-reader'\r\nimport {WasmSectionReader} from './wasm-section-reader'\r\nimport {parseContractMeta, parseSpec} from './xdr-spec-parser'\r\n\r\n/**\r\n * Parse contract metadata from WASM sections\r\n * @param {Buffer} rawWasm\r\n * @return {ParsedWasmMeta}\r\n */\r\nexport function parseContractMetadata(rawWasm) {\r\n    const wasmSectionReader = new WasmSectionReader(rawWasm)\r\n    const sections = wasmSectionReader.readCustomSections()\r\n    const res = {}\r\n    for (const section of sections) {\r\n        switch (section.name) {\r\n            case 'contractenvmetav0':\r\n                const v = xdr.ScEnvMetaEntry.fromXDR(section.contents).value()._attributes\r\n                res.interfaceVersion = `${v.protocol}.${v.preRelease}`\r\n                break\r\n            case 'contractmetav0':\r\n                Object.assign(res, parseContractMeta(parseSectionEntriesXdr(section.contents, xdr.ScMetaEntry)))\r\n                break\r\n            case 'contractspecv0':\r\n                Object.assign(res, parseSpec(parseSectionEntriesXdr(section.contents, xdr.ScSpecEntry)))\r\n                break\r\n            default:\r\n                res[section.name] = section.contents.toString()\r\n                break\r\n        }\r\n    }\r\n    return res\r\n}\r\n\r\nconst index = {parseContractMetadata}\r\n\r\nexport default index\r\n\r\n/**\r\n * @typedef {{}} ParsedWasmMeta\r\n * @property {{}} functions\r\n * @property {{}} [errors]\r\n * @property {{}} [enums]\r\n * @property {{}} [structs]\r\n * @property {{}} [unions]\r\n * @property {string} rustVersion\r\n * @property {string} sdkVersion\r\n * @property {string} interfaceVersion\r\n */"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__755__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","parseSectionEntriesXdr","buffer","xdrContract","reader","XdrReader","entries","eof","push","read","constructor","source","Buffer","isBuffer","Array","Error","from","_buffer","_length","length","_index","advance","size","padding","i","rewind","subarray","readInt32BE","readUInt32BE","readBigInt64BE","readBigUInt64BE","readFloatBE","readDoubleBE","ensureInputConsumed","WasmSectionReader","data","pointer","readCustomSections","sections","sectionType","readUint8","readVarUint32","sectionStart","name","readString","contents","result","shift","byte","toString","parseContractMeta","meta","res","_value","val","rustVersion","sdkVersion","parseSpec","SpecParser","parse","addSpec","attr","parser","spec","value","_attributes","_arm","parseFunction","parseStruct","parseUnion","parseEnum","parseError","parseEvent","console","log","into","withDocs","inputs","map","a","parseFuncArgument","outputs","parseParameterType","fields","f","parseParameter","parseStructName","cases","c","type","t","dataFormat","evt","prefixTopics","params","p","pa","param","location","typeName","switch","valueType","n","elementType","keyType","okType","errorType","valueTypes","v","join","replace","test","toLowerCase","structName","lib","arg","descriptor","doc","parseContractMetadata","rawWasm","section","xdr","ScEnvMetaEntry","fromXDR","interfaceVersion","protocol","preRelease","assign","ScMetaEntry","ScSpecEntry"],"ignoreList":[],"sourceRoot":""}