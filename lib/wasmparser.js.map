{"version":3,"file":"wasmparser.js","mappings":"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","sources":["webpack://sorobanwasmparser/webpack/universalModuleDefinition","webpack://sorobanwasmparser/external umd \"@stellar/stellar-base\"","webpack://sorobanwasmparser/webpack/bootstrap","webpack://sorobanwasmparser/webpack/runtime/define property getters","webpack://sorobanwasmparser/webpack/runtime/hasOwnProperty shorthand","webpack://sorobanwasmparser/./src/xdr-reader.js","webpack://sorobanwasmparser/./src/wasm-section-reader.js","webpack://sorobanwasmparser/./src/xdr-spec-parser.js","webpack://sorobanwasmparser/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@stellar/stellar-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@stellar/stellar-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sorobanwasmparser\"] = factory(require(\"@stellar/stellar-base\"));\n\telse\n\t\troot[\"sorobanwasmparser\"] = factory(root[\"@stellar/stellar-base\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__755__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__755__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n *\r\n * @param {Buffer} buffer\r\n * @param {{read: function}} xdrContract\r\n * @return {{}[]}\r\n */\r\nexport function parseSectionEntriesXdr(buffer, xdrContract) {\r\n    const reader = new XdrReader(buffer)\r\n    const entries = []\r\n    while (!reader.eof) {\r\n        entries.push(xdrContract.read(reader))\r\n    }\r\n    return entries\r\n}\r\n\r\nclass XdrReader {\r\n    /**\r\n     * @constructor\r\n     * @param {Buffer} source - Buffer containing serialized data\r\n     */\r\n    constructor(source) {\r\n        if (!Buffer.isBuffer(source)) {\r\n            if (source instanceof Array) {\r\n                source = Buffer.from(source)\r\n            } else\r\n                throw new Error('Source not specified')\r\n        }\r\n\r\n        this._buffer = source\r\n        this._length = source.length\r\n        this._index = 0\r\n    }\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _buffer\r\n    /**\r\n     * @type {Number}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _length\r\n    /**\r\n     * @type {Number}\r\n     * @private\r\n     * @readonly\r\n     */\r\n    _index\r\n\r\n    /**\r\n     * Check if the reader reached the end of the input buffer\r\n     * @return {Boolean}\r\n     */\r\n    get eof() {\r\n        return this._index === this._length\r\n    }\r\n\r\n    /**\r\n     * Advance reader position, check padding and overflow\r\n     * @param {Number} size - Bytes to read\r\n     * @return {Number} Position to read from\r\n     * @private\r\n     */\r\n    advance(size) {\r\n        const from = this._index\r\n        // advance cursor position\r\n        this._index += size\r\n        // check buffer boundaries\r\n        if (this._length < this._index)\r\n            throw new Error(\r\n                'attempt to read outside the boundary of the buffer'\r\n            )\r\n        // check that padding is correct for Opaque and String\r\n        const padding = 4 - (size % 4 || 4)\r\n        if (padding > 0) {\r\n            for (let i = 0; i < padding; i++)\r\n                if (this._buffer[this._index + i] !== 0)\r\n                    // all bytes in the padding should be zeros\r\n                    throw new Error('Invalid padding')\r\n            this._index += padding\r\n        }\r\n        return from\r\n    }\r\n\r\n    /**\r\n     * Reset reader position\r\n     */\r\n    rewind() {\r\n        this._index = 0\r\n    }\r\n\r\n    /**\r\n     * Read byte array from the buffer\r\n     * @param {Number} size - Bytes to read\r\n     * @return {Buffer} - Sliced portion of the underlying buffer\r\n     */\r\n    read(size) {\r\n        const from = this.advance(size)\r\n        return this._buffer.subarray(from, from + size)\r\n    }\r\n\r\n    /**\r\n     * Read i32 from buffer\r\n     * @return {Number}\r\n     */\r\n    readInt32BE() {\r\n        return this._buffer.readInt32BE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read u32 from buffer\r\n     * @return {Number}\r\n     */\r\n    readUInt32BE() {\r\n        return this._buffer.readUInt32BE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read i64 from buffer\r\n     * @return {BigInt}\r\n     */\r\n    readBigInt64BE() {\r\n        return this._buffer.readBigInt64BE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Read u64 from buffer\r\n     * @return {BigInt}\r\n     */\r\n    readBigUInt64BE() {\r\n        return this._buffer.readBigUInt64BE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Read float from buffer\r\n     * @return {Number}\r\n     */\r\n    readFloatBE() {\r\n        return this._buffer.readFloatBE(this.advance(4))\r\n    }\r\n\r\n    /**\r\n     * Read double from buffer\r\n     * @return {Number}\r\n     */\r\n    readDoubleBE() {\r\n        return this._buffer.readDoubleBE(this.advance(8))\r\n    }\r\n\r\n    /**\r\n     * Ensure that input buffer has been consumed in full, otherwise it's a type mismatch\r\n     */\r\n    ensureInputConsumed() {\r\n        if (this._index !== this._length)\r\n            throw new Error(`Invalid XDR contract typecast - source buffer not entirely consumed`)\r\n    }\r\n}","/**\r\n * Minimalistic WASM metadata reader\r\n */\r\nexport class WasmSectionReader {\r\n    constructor(data) {\r\n        this.data = data\r\n    }\r\n\r\n    /**\r\n     * @type {Buffer}\r\n     * @private\r\n     */\r\n    data\r\n    /**\r\n     * Current reader position\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    pointer = 8\r\n\r\n    /**\r\n     * Read custom metadata sections from raw WASM\r\n     * @return {{name: string, contents: Buffer}[]}\r\n     */\r\n    readCustomSections() {\r\n        const sections = []\r\n        while (this.pointer < this.data.length) {\r\n            const sectionType = this.readUint8()\r\n            let length = this.readVarUint32()\r\n            if (sectionType === 0) { //accumulate only custom sections\r\n                const sectionStart = this.pointer\r\n                const name = this.readString()\r\n                length -= this.pointer - sectionStart\r\n                sections.push({\r\n                    name,\r\n                    contents: this.data.subarray(this.pointer, this.pointer + length)\r\n                })\r\n            }\r\n            this.pointer += length\r\n        }\r\n        return sections\r\n    }\r\n\r\n    /**\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    readUint8() {\r\n        return this.data.readUint8(this.pointer++)\r\n    }\r\n\r\n    /**\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    readVarUint32() {\r\n        let result = 0\r\n        let shift = 0\r\n        while (true) {\r\n            let byte = this.readUint8()\r\n            result |= (byte & 0x7f) << shift\r\n            shift += 7\r\n            if ((byte & 0x80) === 0)\r\n                break\r\n        }\r\n        return result >>> 0\r\n    }\r\n\r\n    /**\r\n     * @return {string}\r\n     * @private\r\n     */\r\n    readString() {\r\n        const length = this.readVarUint32()\r\n        const contents = this.data.subarray(this.pointer, this.pointer + length)\r\n        this.pointer += length\r\n        return contents.toString('utf-8')\r\n    }\r\n}","export function parseContractMeta(meta) {\r\n    const res = {}\r\n    for (const {_value} of meta) {\r\n        const key = _value.key().toString()\r\n        const val = _value.val().toString()\r\n        switch (key) {\r\n            case 'rsver':\r\n                res.rustVersion = val\r\n                break\r\n            case 'rssdkver':\r\n                res.sdkVersion = val\r\n                break\r\n        }\r\n    }\r\n    return res\r\n}\r\n\r\nexport function parseSpec(entries) {\r\n    return new SpecParser().parse(entries)\r\n}\r\n\r\n\r\nclass SpecParser {\r\n    constructor() {\r\n        this.res = {}\r\n    }\r\n\r\n    /**\r\n     * @type {{}}\r\n     */\r\n    res\r\n\r\n    addSpec(key, attr, parser) {\r\n        //this.parseFunction(attr), attr.doc\r\n        let spec = this.res[key]\r\n        if (spec === undefined) {\r\n            spec = this.res[key] = {}\r\n        }\r\n        parser.call(this, attr, spec)\r\n    }\r\n\r\n    parse(entries) {\r\n        for (const spec of entries) {\r\n            const value = spec.value()\r\n            const {_attributes: attr} = value\r\n            switch (spec._arm) {\r\n                case 'functionV0':\r\n                    this.addSpec('functions', attr, this.parseFunction)\r\n                    break\r\n                case 'udtStructV0':\r\n                    this.addSpec('structs', attr, this.parseStruct)\r\n                    break\r\n                case 'udtUnionV0':\r\n                    this.addSpec('unions', attr, this.parseUnion)\r\n                    break\r\n                case 'udtEnumV0':\r\n                    this.addSpec('enums', attr, this.parseEnum)\r\n                    break\r\n                case 'udtErrorEnumV0':\r\n                    this.addSpec('errors', attr, this.parseError)\r\n                    break\r\n                default:\r\n                    console.log('Unknown spec type: ' + spec._arm)\r\n                    break\r\n            }\r\n        }\r\n        return this.res\r\n    }\r\n\r\n    parseFunction(attr, into) {\r\n        const inputs = {}\r\n        attr.inputs.forEach(i => this.parseParameter(i, inputs))\r\n        into[attr.name.toString()] = this.withDocs({\r\n            inputs,\r\n            outputs: attr.outputs.map(o => this.parseParameterType(o))\r\n        }, attr)\r\n    }\r\n\r\n    parseStruct(attr, into) {\r\n        const fields = {}\r\n        attr.fields.forEach(f => this.parseParameter(f, fields))\r\n        into[this.parseStructName(attr)] = this.withDocs({fields}, attr)\r\n    }\r\n\r\n    parseUnion(attr, into) {\r\n        const cases = {}\r\n        attr.cases.forEach(c => {\r\n            const value = c.value()\r\n            cases[value.name().toString()] = value.type ?\r\n                value.type().map(t => this.parseParameterType(t)) :\r\n                []\r\n        })\r\n        into[this.parseStructName(attr)] = this.withDocs({cases}, attr)\r\n    }\r\n\r\n    parseEnum(attr, into) {\r\n        const cases = {}\r\n        attr.cases.forEach(c => {\r\n            const value = c.value()\r\n            if (value.name) {\r\n                cases[value.name().toString()] = value.value()\r\n            } else {\r\n                const attr = c._attributes\r\n                cases[attr.name.toString()] = this.withDocs({value}, attr)\r\n            }\r\n        })\r\n        into[this.parseStructName(attr)] = this.withDocs({cases}, attr)\r\n    }\r\n\r\n    parseError(attr, into) {\r\n        attr.cases.forEach(c => {\r\n            const attr = c._attributes\r\n            into[attr.name.toString()] = this.withDocs({value: attr.value}, attr)\r\n        })\r\n    }\r\n\r\n    parseParameterType(type) {\r\n        const typeName = type.switch().name\r\n        switch (typeName) {\r\n            case 'scSpecTypeOption':\r\n                return `option<${this.parseParameterType(type.value().valueType())}>`\r\n            case 'scSpecTypeBytesN':\r\n                return `bytesn<${type.value().n()}>`\r\n            case 'scSpecTypeVec':\r\n                return `vec<${this.parseParameterType(type.value().elementType())}>`\r\n            case 'scSpecTypeMap':\r\n                return `map<${this.parseParameterType(type.value().keyType())},${this.parseParameterType(type.value().valueType())}>`\r\n            case 'scSpecTypeResult':\r\n                return `result<${this.parseParameterType(type.value().okType())},${this.parseParameterType(type.value().errorType())}>`\r\n            case 'scSpecTypeTuple':\r\n                return `tuple<${type.value().valueTypes().map(v => this.parseParameterType(v)).join()}>`\r\n            case 'scSpecTypeUdt':\r\n                return type.value().name().toString()\r\n            default:\r\n                return typeName.replace('scSpecType', '').toLowerCase()\r\n        }\r\n    }\r\n\r\n    parseStructName(value) {\r\n        let structName = value.name.toString()\r\n        if (value.lib.length) {\r\n            structName += ':' + value.lib.toString()\r\n        }\r\n        return structName\r\n    }\r\n\r\n    parseParameter(param, into) {\r\n        const attr = param._attributes\r\n        into[attr.name.toString()] = this.withDocs({type: this.parseParameterType(attr.type)}, attr)\r\n    }\r\n\r\n    withDocs(descriptor, attr) {\r\n        if (attr.doc?.length) {\r\n            descriptor.doc = attr.doc.toString()\r\n        }\r\n        return descriptor\r\n    }\r\n}\r\n\r\n","import {xdr} from '@stellar/stellar-base'\r\nimport {parseSectionEntriesXdr} from './xdr-reader'\r\nimport {WasmSectionReader} from './wasm-section-reader'\r\nimport {parseContractMeta, parseSpec} from './xdr-spec-parser'\r\n\r\n/**\r\n * Parse contract metadata from WASM sections\r\n * @param {Buffer} rawWasm\r\n * @return {ParsedWasmMeta}\r\n */\r\nexport function parseContractMetadata(rawWasm) {\r\n    const wasmSectionReader = new WasmSectionReader(rawWasm)\r\n    const sections = wasmSectionReader.readCustomSections()\r\n    const res = {}\r\n    for (const section of sections) {\r\n        switch (section.name) {\r\n            case 'contractenvmetav0':\r\n                res.interfaceVersion = xdr.ScEnvMetaEntry.fromXDR(section.contents).value().toString()\r\n                break\r\n            case 'contractmetav0':\r\n                Object.assign(res, parseContractMeta(parseSectionEntriesXdr(section.contents, xdr.ScMetaEntry)))\r\n                break\r\n            case 'contractspecv0':\r\n                Object.assign(res, parseSpec(parseSectionEntriesXdr(section.contents, xdr.ScSpecEntry)))\r\n                break\r\n        }\r\n    }\r\n    return res\r\n}\r\n\r\nconst index = {parseContractMetadata}\r\n\r\nexport default index\r\n\r\n/**\r\n * @typedef {{}} ParsedWasmMeta\r\n * @property {{}} functions\r\n * @property {{}} [errors]\r\n * @property {{}} [enums]\r\n * @property {{}} [structs]\r\n * @property {{}} [unions]\r\n * @property {string} rustVersion\r\n * @property {string} sdkVersion\r\n * @property {string} interfaceVersion\r\n */"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__755__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","parseSectionEntriesXdr","buffer","xdrContract","reader","XdrReader","entries","eof","push","read","constructor","source","Buffer","isBuffer","Array","Error","from","_buffer","_length","length","_index","advance","size","padding","i","rewind","subarray","readInt32BE","readUInt32BE","readBigInt64BE","readBigUInt64BE","readFloatBE","readDoubleBE","ensureInputConsumed","WasmSectionReader","data","pointer","readCustomSections","sections","sectionType","readUint8","readVarUint32","sectionStart","name","readString","contents","result","shift","byte","toString","parseContractMeta","meta","res","_value","val","rustVersion","sdkVersion","SpecParser","addSpec","attr","parser","spec","parse","value","_attributes","_arm","parseFunction","parseStruct","parseUnion","parseEnum","parseError","console","log","into","inputs","forEach","parseParameter","withDocs","outputs","map","parseParameterType","fields","f","parseStructName","cases","c","type","t","typeName","switch","valueType","n","elementType","keyType","okType","errorType","valueTypes","v","join","replace","toLowerCase","structName","lib","param","descriptor","doc","parseContractMetadata","rawWasm","section","interfaceVersion","xdr","ScEnvMetaEntry","fromXDR","assign","ScMetaEntry","ScSpecEntry"],"sourceRoot":""}