!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@stellar/stellar-base")):"function"==typeof define&&define.amd?define(["@stellar/stellar-base"],t):"object"==typeof exports?exports.sorobanwasmparser=t(require("@stellar/stellar-base")):e.sorobanwasmparser=t(e["@stellar/stellar-base"])}(this,(e=>(()=>{"use strict";var t={755:t=>{t.exports=e}},r={};function s(e){var a=r[e];if(void 0!==a)return a.exports;var n=r[e]={exports:{}};return t[e](n,n.exports,s),n.exports}s.d=(e,t)=>{for(var r in t)s.o(t,r)&&!s.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var a={};s.d(a,{default:()=>h});var n=s(755);function i(e,t){const r=new o(e),s=[];for(;!r.eof;)s.push(t.read(r));return s}class o{constructor(e){if(!Buffer.isBuffer(e)){if(!(e instanceof Array))throw new Error("Source not specified");e=Buffer.from(e)}this._buffer=e,this._length=e.length,this._index=0}_buffer;_length;_index;get eof(){return this._index===this._length}advance(e){const t=this._index;if(this._index+=e,this._length<this._index)throw new Error("attempt to read outside the boundary of the buffer");const r=4-(e%4||4);if(r>0){for(let e=0;e<r;e++)if(0!==this._buffer[this._index+e])throw new Error("Invalid padding");this._index+=r}return t}rewind(){this._index=0}read(e){const t=this.advance(e);return this._buffer.subarray(t,t+e)}readInt32BE(){return this._buffer.readInt32BE(this.advance(4))}readUInt32BE(){return this._buffer.readUInt32BE(this.advance(4))}readBigInt64BE(){return this._buffer.readBigInt64BE(this.advance(8))}readBigUInt64BE(){return this._buffer.readBigUInt64BE(this.advance(8))}readFloatBE(){return this._buffer.readFloatBE(this.advance(4))}readDoubleBE(){return this._buffer.readDoubleBE(this.advance(8))}ensureInputConsumed(){if(this._index!==this._length)throw new Error("Invalid XDR contract typecast - source buffer not entirely consumed")}}class c{constructor(e){this.data=e}data;pointer=8;readCustomSections(){const e=[];for(;this.pointer<this.data.length;){const t=this.readUint8();let r=this.readVarUint32();if(0===t){const t=this.pointer,s=this.readString();r-=this.pointer-t,e.push({name:s,contents:this.data.subarray(this.pointer,this.pointer+r)})}this.pointer+=r}return e}readUint8(){return this.data.readUint8(this.pointer++)}readVarUint32(){let e=0,t=0;for(;;){let r=this.readUint8();if(e|=(127&r)<<t,t+=7,!(128&r))break}return e>>>0}readString(){const e=this.readVarUint32(),t=this.data.subarray(this.pointer,this.pointer+e);return this.pointer+=e,t.toString("utf-8")}}function u(e){const t={};for(const{_value:r}of e){const e=r.key().toString(),s=r.val().toString();switch(e){case"rsver":t.rustVersion=s;break;case"rssdkver":t.sdkVersion=s}}return t}class p{constructor(){this.res={}}res;addSpec(e,t,r){let s=this.res[e];void 0===s&&(s=this.res[e]={}),r.call(this,t,s)}parse(e){for(const t of e){const e=t.value(),{_attributes:r}=e;switch(t._arm){case"functionV0":this.addSpec("functions",r,this.parseFunction);break;case"udtStructV0":this.addSpec("structs",r,this.parseStruct);break;case"udtUnionV0":this.addSpec("unions",r,this.parseUnion);break;case"udtEnumV0":this.addSpec("enums",r,this.parseEnum);break;case"udtErrorEnumV0":this.addSpec("errors",r,this.parseError);break;default:console.log("Unknown spec type: "+t._arm)}}return this.res}parseFunction(e,t){const r={};e.inputs.forEach((e=>this.parseParameter(e,r))),t[e.name.toString()]=this.withDocs({inputs:r,outputs:e.outputs.map((e=>this.parseParameterType(e)))},e)}parseStruct(e,t){const r={};e.fields.forEach((e=>this.parseParameter(e,r))),t[this.parseStructName(e)]=this.withDocs({fields:r},e)}parseUnion(e,t){const r={};e.cases.forEach((e=>{const t=e.value();r[t.name().toString()]=t.type?t.type().map((e=>this.parseParameterType(e))):[]})),t[this.parseStructName(e)]=this.withDocs({cases:r},e)}parseEnum(e,t){const r={};e.cases.forEach((e=>{const t=e.value();if(t.name)r[t.name().toString()]=t.value();else{const s=e._attributes;r[s.name.toString()]=this.withDocs({value:t},s)}})),t[this.parseStructName(e)]=this.withDocs({cases:r},e)}parseError(e,t){e.cases.forEach((e=>{const r=e._attributes;t[r.name.toString()]=this.withDocs({value:r.value},r)}))}parseParameterType(e){const t=e.switch().name;switch(t){case"scSpecTypeOption":return`option<${this.parseParameterType(e.value().valueType())}>`;case"scSpecTypeBytesN":return`bytesn<${e.value().n()}>`;case"scSpecTypeVec":return`vec<${this.parseParameterType(e.value().elementType())}>`;case"scSpecTypeMap":return`map<${this.parseParameterType(e.value().keyType())},${this.parseParameterType(e.value().valueType())}>`;case"scSpecTypeResult":return`result<${this.parseParameterType(e.value().okType())},${this.parseParameterType(e.value().errorType())}>`;case"scSpecTypeTuple":return`tuple<${e.value().valueTypes().map((e=>this.parseParameterType(e))).join()}>`;case"scSpecTypeUdt":return e.value().name().toString();default:return t.replace("scSpecType","").toLowerCase()}}parseStructName(e){let t=e.name.toString();return e.lib.length&&(t+=":"+e.lib.toString()),t}parseParameter(e,t){const r=e._attributes;t[r.name.toString()]=this.withDocs({type:this.parseParameterType(r.type)},r)}withDocs(e,t){return t.doc?.length&&(e.doc=t.doc.toString()),e}}const h={parseContractMetadata:function(e){const t=new c(e).readCustomSections(),r={};for(const e of t)switch(e.name){case"contractenvmetav0":r.interfaceVersion=n.xdr.ScEnvMetaEntry.fromXDR(e.contents).value().toString();break;case"contractmetav0":Object.assign(r,u(i(e.contents,n.xdr.ScMetaEntry)));break;case"contractspecv0":Object.assign(r,(s=i(e.contents,n.xdr.ScSpecEntry),(new p).parse(s)))}var s;return r}};return a.default})()));
//# sourceMappingURL=wasmparser.js.map